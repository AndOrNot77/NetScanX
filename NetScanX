#!/bin/bash

# Pulizia dello schermo
clear

# Colori per i messaggi
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[0;33m'
NC='\033[0m' # Nessun colore

# Funzione per verificare il formato della subnet in CIDR
function is_valid_cidr() {
    [[ "$1" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}/([0-9]|[1-2][0-9]|3[0-2])$ ]]
}

# Funzione per ottenere tutte le subnet attive (compatibile con macOS)
function get_active_subnets() {
    ifconfig | awk '/inet / && !/127.0.0.1/ {print $2"/24"}'
}

# Funzione per mostrare una progress bar
function show_progress() {
    local pid=$1
    local delay=0.1
    local spinstr='|/-\\'
    tput civis  # Nasconde il cursore
    echo -ne "${YELLOW}Scansione in corso${NC} "
    while [ "$(ps a | awk '{print $1}' | grep $pid)" ]; do
        local temp=${spinstr#?}
        printf " [%c]  " "$spinstr"
        spinstr=$temp${spinstr%"$temp"}
        sleep $delay
        printf "\b\b\b\b\b\b"
    done
    tput cnorm  # Ripristina il cursore
    echo -e "${GREEN}Fatto!${NC}"
}

# Ottieni tutte le subnet attive
ACTIVE_SUBNETS=($(get_active_subnets))

# Mostra le subnet attive trovate
echo -e "${BLUE}I: Subnet attive trovate:${NC}"
if [ ${#ACTIVE_SUBNETS[@]} -eq 0 ]; then
    echo -e "${RED}I: Nessuna rete attiva trovata. Puoi inserire una subnet manualmente.${NC}"
else
    for i in "${!ACTIVE_SUBNETS[@]}"; do
        echo "  [$((i+1))] ${ACTIVE_SUBNETS[$i]}"
    done
fi
echo "  [M] Inserisci manualmente una subnet"
echo "  [Q] Esci dallo script"

# Chiedi all'utente di scegliere una subnet
while true; do
    read -p "$(echo -e "${BLUE}D: Scegli una subnet o inserisci manualmente (1/.../M/Q): ${NC}")" scelta
    if [[ "$scelta" == "Q" || "$scelta" == "q" ]]; then
        echo -e "${YELLOW}I: Uscita dallo script.${NC}"
        exit 0
    elif [[ "$scelta" =~ ^[1-9][0-9]*$ && $scelta -ge 1 && $scelta -le ${#ACTIVE_SUBNETS[@]} ]]; then
        SELECTED_SUBNET=${ACTIVE_SUBNETS[$((scelta-1))]}
        echo -e "${GREEN}I: Hai selezionato la subnet ${SELECTED_SUBNET}.${NC}"
        break
    elif [[ "$scelta" == "M" || "$scelta" == "m" ]]; then
        while true; do
            read -p "$(echo -e "${BLUE}D: Inserisci la subnet in formato CIDR (esempio: 192.168.1.0/24): ${NC}")" MANUAL_SUBNET
            if is_valid_cidr "$MANUAL_SUBNET"; then
                SELECTED_SUBNET=$MANUAL_SUBNET
                echo -e "${GREEN}I: Subnet inserita correttamente: ${SELECTED_SUBNET}.${NC}"
                break 2
            else
                echo -e "${RED}I: Formato CIDR non valido. Riprova.${NC}"
            fi
        done
    else
        echo -e "${RED}I: Scelta non valida. Riprova.${NC}"
    fi
done

SUBNET=$SELECTED_SUBNET

# Genera il nome del file di output per la scansione degli host
TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
OUTPUT_FILE="$HOME/scan_host_$TIMESTAMP.txt"
echo -e "${GREEN}I: Il file per la scansione degli host sarà salvato in $OUTPUT_FILE${NC}"

# Esegui nmap sulla subnet e salva il risultato nel file di output
echo -e "${YELLOW}I: Scansione della subnet $SUBNET in corso...${NC}"
nmap -sn -oG - "$SUBNET" -vv | grep Up | awk -F " " '{print $2}' > "$OUTPUT_FILE" &
host_scan_pid=$!

# Mostra la progress bar durante la scansione degli host
show_progress $host_scan_pid

# Controlla se il file è stato creato con successo
if [ -f "$OUTPUT_FILE" ]; then
    echo -e "${GREEN}I: Scansione completata. Risultati salvati in $OUTPUT_FILE${NC}"

# Chiedi all'utente se vuole visualizzare l'elenco degli host
while true; do
    echo -e "${BLUE}I: Cosa vuoi fare adesso:${NC}"
    echo "  [S] Scansione delle porte degli host rilevati"
    echo "  [L] Lista degli IP rilevati"
    read -p "$(echo -e "${BLUE}D: Scegli (S/L) ${NC}")" scelta
    if [[ "$scelta" == "s" || "$scelta" == "S" ]]; then
        break
    elif [[ "$scelta" == "l" || "$scelta" == "L" ]]; then
        cat "$OUTPUT_FILE"
        exit 0 # Interrompe lo script
    else
        echo -e "${RED}I: Scelta non valida. Riprova.${NC}"
    fi
done

    # Genera il nome del file di output per la scansione delle porte
    DETTAGLIATO_FILE="$HOME/scan_port_$TIMESTAMP.txt"
    echo -e "${GREEN}I: Il file per la scansione delle porte sarà salvato in $DETTAGLIATO_FILE${NC}"

    # Esegui un secondo nmap usando l'output precedente come input e salva i risultati dettagliati
    echo -e "${YELLOW}I: Esecuzione di nmap con input dal file $OUTPUT_FILE...${NC}"

    # Esegui nmap in background
    nmap -iL "$OUTPUT_FILE" -oN "$DETTAGLIATO_FILE" &
    nmap_pid=$!

    # Mostra la progress bar durante l'esecuzione
    show_progress $nmap_pid

    # Controlla se il file dettagliato è stato creato con successo
    if [ -f "$DETTAGLIATO_FILE" ]; then
        echo -e "${GREEN}I: Scansione dettagliata completata. Risultati salvati in $DETTAGLIATO_FILE${NC}"

        # Chiedi all'utente se vuole aprire il file dettagliato
        read -p "$(echo -e "${BLUE}D: Vuoi aprire il file dei risultati dettagliati? [S/n] ${NC}")" apri_file
        apri_file=${apri_file:-S} # Imposta "S" come scelta predefinita

        if [[ "$apri_file" == "s" || "$apri_file" == "S" ]]; then
            less "$DETTAGLIATO_FILE"
        else
            echo -e "${YELLOW}I: File non aperto. Puoi trovarlo qui: $DETTAGLIATO_FILE${NC}"
        fi
    else
        echo -e "${RED}I: Errore: il file $DETTAGLIATO_FILE non è stato creato.${NC}"
        exit 4
    fi
else
    echo -e "${RED}I: Errore: il file $OUTPUT_FILE non è stato creato.${NC}"
    exit 3
fi
